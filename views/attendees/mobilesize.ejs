<!-- SEARCH BAR -->
<div id="searchBar" class="mobile-search">
  <img class="search-icon" src="https://cdn-icons-png.flaticon.com/512/54/54481.png" alt="Search">

  <div class="search-texts" onclick="focusSearch()">
    <span class="search-line1">Find things to do</span>
    <span class="search-line2" id="locationText">in Kampala, UG</span>
    <input type="text" id="mobile-search-input" placeholder="Search location..." style="display: none;" />
    <ul class="location-dropdown" id="mobile-location-suggestions"></ul>
  </div>

  <div class="filter-btn">
    <i class="fas fa-sliders-h" id="mobile-location-dropdown-btn"></i>
  </div>
</div>

<!-- BOTTOM NAVIGATION -->
<div id="bottomNav" class="bottom-nav">
  <a href="/"><i class="fas fa-home nav-item active"></i></a>
  <i class="far fa-heart nav-item"></i>
  <i class="far fa-calendar nav-item"></i>
  <i class="far fa-comment nav-item"></i>
  <i class="fas fa-bars nav-item" onclick="toggleMenu()"></i>
</div>

<!-- SEARCH RESULTS -->
<!-- <div id="results" class="search-results"></div> -->

<script>
  let locations = []; // make accessible globally

  function focusSearch() {
    const input = document.getElementById("mobile-search-input");
    const locationText = document.getElementById("locationText");
    const suggestions = document.getElementById("mobile-location-suggestions");

    locationText.style.display = "none";
    input.style.display = "block";
    input.focus();

    if (locations.length) {
      populateSuggestions(locations.slice(0, 10), input, suggestions); // limit initial list
    }
  }

  async function loadLocations() {
    try {
      const res = await fetch('/locations');
      return await res.json();
    } catch (err) {
      console.error('Error fetching locations:', err);
      return [];
    }
  }

  async function searchByLocation(location) {
    const resultsContainer = document.getElementById('results');
    resultsContainer.innerHTML = '<p>Loading events for location...</p>';

    try {
      const res = await fetch(`/search/location?location=${encodeURIComponent(location)}`);
      const html = await res.text();
      resultsContainer.innerHTML = html;
    } catch (err) {
      resultsContainer.innerHTML = '<p>Failed to load events.</p>';
    }
  }

  function populateSuggestions(locationList, input, dropdown) {
    dropdown.innerHTML = '';
    locationList.forEach(loc => {
      const li = document.createElement('li');
      li.textContent = loc;
      li.addEventListener('click', () => {
        input.value = loc;
        document.getElementById("locationText").textContent = "in " + loc;
        document.getElementById("locationText").style.display = "inline";
        input.style.display = "none";
        dropdown.style.display = 'none';
        searchByLocation(loc);
      });
      dropdown.appendChild(li);
    });
    dropdown.style.display = 'block';
  }

  document.addEventListener('DOMContentLoaded', async () => {
    locations = await loadLocations();

    const mobileBtn = document.getElementById('mobile-location-dropdown-btn');
    const mobileInput = document.getElementById('mobile-search-input');
    const mobileSuggestions = document.getElementById('mobile-location-suggestions');

    if (mobileBtn && mobileInput && mobileSuggestions) {
      mobileBtn.addEventListener('click', () => {
        populateSuggestions(locations.slice(0, 10), mobileInput, mobileSuggestions);
      });
    }

    document.addEventListener('click', (e) => {
      if (!mobileBtn.contains(e.target) &&
          !mobileInput.contains(e.target) &&
          !mobileSuggestions.contains(e.target)) {
        mobileSuggestions.style.display = 'none';
      }
    });

    mobileInput?.addEventListener('input', (e) => {
      const value = e.target.value;
      if (value.length >= 2) {
        const filtered = locations.filter(loc =>
          loc.toLowerCase().includes(value.toLowerCase())
        );
        populateSuggestions(filtered, mobileInput, mobileSuggestions);
      } else {
        mobileSuggestions.style.display = 'none';
      }
    });
  });
</script>
